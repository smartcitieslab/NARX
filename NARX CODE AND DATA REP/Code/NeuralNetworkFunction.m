function [Y,Xf,Af] = myNeuralNetworkFunction(X,Xi,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 11-Feb-2021 12:37:18.
%
% [Y,Xf,Af] = myNeuralNetworkFunction(X,Xi,~) takes these arguments:
%
%   X = 2xTS cell, 2 inputs over TS timesteps
%   Each X{1,ts} = 8xQ matrix, input #1 at timestep ts.
%   Each X{2,ts} = 1xQ matrix, input #2 at timestep ts.
%
%   Xi = 2x2 cell 2, initial 2 input delay states.
%   Each Xi{1,ts} = 8xQ matrix, initial states for input #1.
%   Each Xi{2,ts} = 1xQ matrix, initial states for input #2.
%
%   Ai = 2x0 cell 2, initial 2 layer delay states.
%   Each Ai{1,ts} = 10xQ matrix, initial states for layer #1.
%   Each Ai{2,ts} = 1xQ matrix, initial states for layer #2.
%
% and returns:
%   Y = 1xTS cell of 2 outputs over TS timesteps.
%   Each Y{1,ts} = 1xQ matrix, output #1 at timestep ts.
%
%   Xf = 2x2 cell 2, final 2 input delay states.
%   Each Xf{1,ts} = 8xQ matrix, final states for input #1.
%   Each Xf{2,ts} = 1xQ matrix, final states for input #2.
%
%   Af = 2x0 cell 2, final 0 layer delay states.
%   Each Af{1ts} = 10xQ matrix, final states for layer #1.
%   Each Af{2ts} = 1xQ matrix, final states for layer #2.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [8.853960103;0.448486071;0.683714286;2.772791694;2.903809501;3.922486391;3.704007906;2.918102819];
x1_step1.gain = [5.07116925845635;15.1114876826679;47.6190476190476;14.67340137639;8.644303806616;5.12912971301817;5.96397621789338;2.10695736230977];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = 29.71428571;
x2_step1.gain = 0.388888888348765;
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.010549146382556343071;-0.010549147462182289006;0.010549145432675845896;0.010549147862055770555;-0.010549146454787884999;0.010549146397210473411;-0.010549144280544162436;-0.010549146703568068953;-0.010549146606009368252;0.010549146481146144325];
IW1_1 = [-0.19171317331410389628 -0.11038664902141190338 -0.033129079076253710456 -0.0073535596299371735682 0.032503249719834648168 0.19897387149875106482 0.072432238835801285304 -0.0036242745874099664 -0.037493192634524989681 -0.030647270405393549353 -0.018775854821799910915 -0.073510636911776811031 -0.087867063266341582928 -0.030858534389167423945 -0.049908172399476070924 0.018515037928566555059;-0.19171317395189763078 -0.11038664850183892152 -0.03312907887084802494 -0.0073535591794168693458 0.032503248863892379716 0.19897387125713067446 0.072432238502043375106 -0.0036242746887438230703 -0.037493192539963339505 -0.030647269297440909996 -0.018775854343170434585 -0.073510636323276076776 -0.087867064164226238443 -0.030858535412112888391 -0.049908173158687778315 0.018515038022729295164;0.19171317336994314617 0.11038664985984480982 0.03312907936859513236 0.0073535600749715128097 -0.032503250607964676022 -0.19897387237894240131 -0.072432239376684623422 0.0036242744981597649866 0.037493192835941810404 0.030647271516285479881 0.0187758553146251915 0.073510637708291276526 0.087867062745077717523 0.03085853355679121085 0.049908171878153453904 -0.018515037916012659636;0.1917131740708460097 0.1103866482369198071 0.033129078773552332604 0.0073535590033037999055 -0.032503248521196112519 -0.19897387104073777087 -0.072432238331430295886 0.0036242747262939046041 0.037493192482467914417 0.030647268861207534185 0.018775854152262957258 0.073510636052322914091 0.087867064445707576681 0.030858535778136571975 0.049908173412010058134 -0.018515038044243970622;-0.19171317366316115161 -0.11038664917599866344 -0.033129079117940447852 -0.0073535596239573128644 0.032503249729633282294 0.1989738718141103313 0.072432238936244980332 -0.0036242745941428458449 -0.037493192686904479316 -0.030647270398846650913 -0.018775854825390615038 -0.073510637010820750747 -0.087867063459854566343 -0.030858534491193544136 -0.04990817252309473484 0.018515037969772787929;0.19171317348723571072 0.11038664911600597207 0.033129079103221333036 0.0073535596367927174785 -0.032503249744218497275 -0.19897387167344127157 -0.072432238897178632953 0.0036242745887602933683 0.037493192664756209986 0.030647270426633285018 0.018775854834421207284 0.073510636978094220928 0.087867063350162796787 0.030858534421082287058 0.049908172448874701943 -0.01851503794858314067;-0.19171317304113583146 -0.11038665063173738745 -0.033129079651444064136 -0.0073535605834926659474 0.032503251598400000055 0.19897387301747510024 0.072432239873836221089 -0.0036242743899666468935 -0.037493193004265172597 -0.030647272776247357767 -0.018775855866292379126 -0.073510638495257310532 -0.08786706194012110227 -0.030858532503714106165 -0.049908171151577820912 0.018515037855608769413;-0.19171317373574112142 -0.11038664901030027787 -0.033129079057150685739 -0.0073535595142767964591 0.032503249516114163242 0.1989738716779418104 0.072432238829528136637 -0.0036242746175047494024 -0.037493192650861088822 -0.030647270127131278489 -0.018775854706452592413 -0.073510636841604914959 -0.087867063634357464585 -0.030858534718758177939 -0.049908172680360157747 0.018515037982995898036;-0.19171317370676349556 -0.11038664907496001377 -0.033129079080896010889 -0.0073535595572471615725 0.032503249599732449149 0.19897387173078226463 0.072432238871170381844 -0.0036242746083434956156 -0.037493192664896674016 -0.030647270233570264586 -0.018775854753034008221 -0.073510636907729715039 -0.087867063565701952754 -0.030858534629462596593 -0.049908172618566268297 0.01851503797775175264;0.19171317366626222656 0.11038664915560700286 0.033129079110669611141 0.0073535596119747850472 -0.032503249706006480391 -0.19897387179471798246 -0.072432238923099509509 0.0036242745966187346965 0.037493192682206410993 0.030647270369046256122 0.018775854812255750315 0.073510636990819250292 0.087867063476344625661 0.030858534514800996934 0.049908172538666313589 -0.018515037970650977811];
IW1_2 = [0.060556361578600031992 0.025727682495267523155;0.060556362599400934132 0.025727683259482193867;-0.060556360850127062545 -0.025727681878491771156;-0.060556362945238681461 -0.025727683531964817137;0.060556361731142635541 0.025727682574006063149;-0.060556361637681146992 -0.025727682520461751803;0.060556359857510594358 0.025727681094657554872;0.060556361945913225742 0.025727682743402136706;0.060556361861549570791 0.02572768267692732494;-0.060556361752635831652 -0.025727682591540096402];

% Layer 2
b2 = 0.007508438888471696479;
LW2_1 = [-0.35462762877968989628 -0.35462762956712612361 0.35462762928657987072 0.35462762963073568567 -0.35462762942812436906 0.35462762911019052314 -0.35462762913035511536 -0.35462762946493109339 -0.35462762944949505206 0.35462762942310138703];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 0.388888888348765;
y1_step1.xoffset = 29.71428571;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
    X = {X};
end
if (nargin < 2), error('Initial input states Xi argument needed.'); end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},2); % samples/series
elseif ~isempty(Xi)
    Q = size(Xi{1},2);
else
    Q = 0;
end

% Input 1 Delay States
Xd1 = cell(1,3);
for ts=1:2
    Xd1{ts} = mapminmax_apply(Xi{1,ts},x1_step1);
end

% Input 2 Delay States
Xd2 = cell(1,3);
for ts=1:2
    Xd2{ts} = mapminmax_apply(Xi{2,ts},x2_step1);
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Rotating delay state position
    xdts = mod(ts+1,3)+1;
    
    % Input 1
    Xd1{xdts} = mapminmax_apply(X{1,ts},x1_step1);
    
    % Input 2
    Xd2{xdts} = mapminmax_apply(X{2,ts},x2_step1);
    
    % Layer 1
    tapdelay1 = cat(1,Xd1{mod(xdts-[1 2]-1,3)+1});
    tapdelay2 = cat(1,Xd2{mod(xdts-[1 2]-1,3)+1});
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
Xf = [Xi(:,xits) X(:,xts)];
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
    Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
